# 第2章-物理层

### **以太网帧（也叫MAC帧）首部分析** 

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC2%E7%AB%A0/711_%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)



- 传输层——数据段（报文段）（Segment）
- 网络层——分组（数据包）（Packet）
- 数据链路层——数据帧（Frame）
- 物理层——比特（Bit）

### 1.物理层

  物理层的主要功能是透明地完成相邻节点之间原始**比特流**的传输。其中“透明”的意思是指物理层并不需要关心比特代表的具体含义，而要考虑的是如何发送“0”和“1”，以及接收端如何识别。物理层在传输介质上作为系统和通讯介质的接口，为数据链路层提供服务。
解决两个硬件之间的通信。

### 2.数据链路层

  数据链路层负责在两个相邻节点之间的线路上无差错地传送以**帧**为单位的数据，通过流量控制和差错控制，将原始不可靠的物理层连接变成无差错的数据通道，并解决多用户竞争问题，使之对网络层显现一条可靠的链路。

### 3.网络层

  网络层是通讯子网的最高层，其主要任务是在数据链路层服务的基础上，实现整个通讯子网内的连接，并通过网络连接交换网络服务**数据单元（packet）**。它主要解决数据传输单元分组在通信子网中的路由选择、拥塞控制和多个网络互连的问题。网络层建立网络连接为传输层提供服务。

### 4.传输层

  传输层既是负责数据通讯的最高层，又是面向网络通信的低三层（物理层、数据链路层和网络层）和面向信息处理的高三层（会话层。表示层、应用层）之间的中间层，是资源子网和通信子网的桥梁，其主要任务是为两台计算机的通信提供可靠的端到端的数据传输服务。传输层反映并扩展了网络层子系统的服务功能，并通过传输层地址为高层提供传输数据的通信接口，使系统之间高层资源的共享不必考虑数据通信方面的问题。

### 5.会话层

  会话层利用传输层提供的端到端数据传输服务，具体实施服务请求者与服务提供者之间的通信、组织和同步它们的会话活动，并管理它们的数据交换过程。会话层提供服务通常需要经过建立连接、数据传输和释放连接三个阶段。会话层是最薄的一层，常被省略。作用：建立和管理应用程序之间的通信。

### 6.表示层

  将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。
  表示层处理的是用户信息的表示问题。端用户（应用进程）之间传送的数据包含“语义”和“语法”两个方面。语义是数据的内容及其含义，它由应用层负责处理；语法是与数据表示形式有关的方面，例如，数据的格式、编码和压缩等。表示层主要用于处理应用实体面向交换的信息的表示方法，包括用户数据的结构和在传输时的比特流（或字节流）的表示，这样，即使每个应用系统有各自的信息表示法，但被交换的信息类型和数值仍能用一种共同的方法来描述。

### 7. 应用层

  作用是**通过应用程序之间的交互完成特定的网络应用**。应用层是直接面向用户的一层，是计算机网络与最终用户之间的界面，在实际应用中，通常把会话层和表示层归入到应用层，使OSI/RM成为一个简化的五层模型。

### OSI与TCP/IP对比

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC2%E7%AB%A0/711_OSITCP%E5%AF%B9%E6%AF%94.png)

### TCP/IP结构

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC2%E7%AB%A0/711TCPIP%E7%BB%93%E6%9E%84.png)

### OSI模型

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC2%E7%AB%A0/OSI%E6%A8%A1%E5%9E%8B.png)

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC2%E7%AB%A0/711%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93.png)

根据10Base5标准（粗缆以太网），网络的拓扑结构有一个明确的限制，即所谓的“5-4-3”规则。这个规则的含义是：

- “5”表示整个网络可以有5个网段。
- “4”表示在这5个网段中，可以使用4个中继器来连接它们。
- “3”表示在5个网段中有3个可以用于连接终端设备，其余的网段用于扩展网络长度

调制速率，通常称为波特率（Baud rate）

CSMA平均重传次数

[计算机网络（第7版）——谢希仁 课后习题3-26_平均重传次数如何计算-CSDN博客](https://blog.csdn.net/Clover_pofu/article/details/105061957)

# 第3章-数据链路层

## 3.1



## 3.2-封装成帧

以太网帧的首部和尾部中，并没有包含帧定界符，因此并不存在透明传输的问题

以太网还规定了帧间间隔时间为96 比特的发送时间（对千带宽为lOMb/s 的传统以太
网， 96 比特的发送时间为9.6μs)

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC3%E7%AB%A0/712-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%89%8D%E5%AF%BC%E7%A0%81.png)

## 3.3-差错控制

两种常用的检错技术：奇偶校验和循环冗余校验

帧尾部中用来存放检错码的字段称为帧检验序列(Frame Check Sequence, FCS) 

出现传输错误的比特数量占这段时间内传输比特总数量的比例，称为误码率

### 差错类型

1. 比特1 可能会变成比特o, 而比特0也可能变成比特l 。这种传输差错称为比特差错。
2. 误码（比特差错）只是传输差错中的一种。从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序和分组重复

## 3.4-可靠传输/流量控制

### TCP/IP中可靠不可靠传输的例子

1. 运输层中的**TCP** 向其上层提供的是面向连接的**可靠传输服务**，而**UDP** 向其上层提供的是**无连接、不可靠传输服务**。
2. 如果网络接口层使用的是信道易受干扰的802.11 无线局域网，那么其数据链路层必须实现可靠传输。
3. 如果网络接口层使用的是信道质量比无线局域网好很多的以太网，那么其数据链路层不要求实现可靠传输。
4. 网际层的**IP** 向其上层提供的是**无连接、不可靠**传输服务。

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC3%E7%AB%A0/712-TCPIP%E5%8F%AF%E9%9D%A0%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.png)

### 可靠不可靠依据

- 有线链路的误码率比较低，为了减小开销，并不要求数据链路层向其上层提供可靠传输服务，即使出现了误码，可靠传输的问题也由其上层处理。

- 而无线链路易受干扰，误码率比较高，因此要求数据链路层必须向其上层提供可靠传输服务。

### 可靠传输机制

三种实现可靠传输的机制：停止－等待协议、回退N帧协议、选择重传协议

### 停止等待协议(Stop-and-Wait, SW)

1. 使用具有**确认、否认、重传、超时重传和分组编号**机制的停止－等待协议，就可以在不可靠的信道上实现**可靠传输**。停止－等待协议属千**自动请求重传**(Automatic Repeat-reQuest, **ARQ**) 协议。
2. 发送方发送完一个数据分组后，必须**暂时保留**已发送的数据分组的副本，以便在**超时重传**时使用，只有在收到相应的**确认分组**后才能从**缓存**中删除该数据分组。
3. ![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC3%E7%AB%A0/712-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E7%9A%84%E9%97%AE%E9%A2%98.png)

#### 确认、否认

1. 如果没有**误码**，就接受该数据分组，并给发送方发送**ACK分组**。发送方收到ACK分组后就可以发送下一个数据分组。

2. 如果存在误码，就丢弃该数据分组，并给发送方发送**NAK分组**，发送方收到NAK分组后就会**重传**之前出现误码的这个数据分组。

   #### 重传、超时重传

1. 发送方将永久等待接收方的确认分组或否认分组。为了解决该问题，发送方可在每发送完一个数据分组时就启动一个超时计时器(Timeout Timer) 。
2. 超时计时器所设置的超时重传时间(Retransmission Time-Out, RTO),一般可将RTO设置为略大于收发双方的平均往返时间RTT
3. 停止—等待协议补充了超时重传机制后，就可以不使用否认机制了

#### 分组编号

1. 为了解决该问题，发送方必须给每个数据分组带上不同的序号，每发送一个新的数据分组就把它的序号加1 。
2. 接收方连续收到序号相同的数据分组时，就可识别出分组重复这种传输差错。这时接收方应当丢弃重复的数据分组，并且还必须向发送方再发送一个确认分组。
3. 发送可用序号有0 和1 这两个。
4. 在数据链路层实现停止－等待协议时可以不对确认分组编序号。

### 停止－等待协议的信道利用率

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC3%E7%AB%A0/712-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png)
$$
发送方发送数据分组产生的发送时延为T_{D}\\
接收方发送确认分组产生的发送时延为T_{A}\\
发双方之间的往返时间为RTT\\
发送方在经过时间(TD+RTT+T_{A})后，就可以发送下一个新的数据分组\\
信道利用率U=\frac{TD}{TD +RTT+TA}
$$

### 停止－等待协议的适用情况

信道利用率低的情况不适用

1. 对于数据分组发送时延TD较小、但往返时间RTT很大（例如卫星链路）的应用，就不适于使用停止－等待协议来实现可靠传输。
2. 对千往返时间RTT远小千数据分组发送时延TD 的应用（例如无线局域网），使用停止—等待协议的信道利用率还是比较高的。

### 回退n帧协议-(Go-back-N, GBN) 

采用流水线传输方式，并且利用发送窗口来限制发送方连续发送数据分组的数量，这属于连续ARQ协议。

#### 发送窗口/维护窗口

1. 发送方需要维护一个发送窗口，在未收到接收方确认分组的情况下，发送方可将序号落入发送窗口内的所有数据分组连续发送出去。
2. 接收方需要维护一个接收窗口，只有正确到达接收方且序号落入接收窗口内的数据分组才被接收方接收。
3. 在回退N帧协议的工作过程中，发送方的发送窗口和接收方的接收窗口按上述规则不断向前滑动。因此，这类协议又称为**滑动窗口协议**。

#### 缓存

1. 请读者注意，发送方应将发送缓存中已收到确认的数据分组的副本删除，而接收方应当从接收缓存中尽快取走已正确接收的数据分组。

#### 重传

1. 一旦1 号数据分组出现差错，其后连续发送的2号和3 号数据分组都要被重传。这就是回退N帧协议名称的由来，即一旦出错就需要退回去重传已发送过的N个数据分组
2. 在本例中，发送方收到针对0号数据分组的重复确认，就表明接收方未按序正确接收1号数据分组。千是，可以不等1 号数据分组的重传计时器超时就立刻重传1号数据分组。至千收到几个重复确认就立刻重传，由具体实现决定。
3. 回退N帧协议的接收方采用累积确认的方式

#### 累积确认优点

1. 容易实现。
2. 减少向网络中注入确认分组的数量。
3. 即使确认分组丢失也可能不必重传数据分组。

#### 累积确认缺点

不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。

#### 窗口大小

1. 下回退N帧协议的发送窗口尺寸$ W_{T}$ 和接收窗口尺寸$ W_{R}$ 
2. $W_{R} = 1,1 < W_{T}<=2^{n}-1 $其中， n 是用来给数据分组编序号的**比特数量**。如果从滑动窗口协议的角度来看停止－等待协议，其$W_{T}$和$W_{R}$ 的取值都固定为1 

#### 信道传输率

“信道平均（实际）数据传输速率=信道利用率x信道带宽（最大数据传输速率）”

“信道平均（实际）数据传输速率=发送周期内发送的数据量/发送周期”。

### 回退n帧协议信道利用率

![](./../image/408%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%BD%91%E7%AC%AC3%E7%AB%A0/712-gbn%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png)
$$
若nT_{D}<T_{D}+RTT+T_{A}:U = \frac{nT_{D}}{T_{D}+RTT+T_{A}}\\
若nT_{D}>=T_{D}+RTT+T_{A}:U=1
$$


### 选择重传协议

为了使发送方仅重传出现差错的数据分组，接收方不能再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。显然，选择重传协议比回退N帧协议复杂，并且接收方需要有足够的缓存空间，来暂存失序但正确到达接收方且序号落入接收窗口内的数据分组。

选择重传协议的$W_{T}和W_{R}$都大于1 

$ W_{T}+W_{R}<2^{n} $

因此WR不应超过序号范围的一半，即$W_{R} \sim 2^{n}-1 $

在选择重传协议中， $W_{T}和W_{R}$是相同的



# 第6章-传输层

### UDP和TCP长度

udp首部8 tcp首部20 IP首部20

[网络-UDP，TCP数据包的最大传输长度分析_udp最大传输多少字节-CSDN博客](https://blog.csdn.net/flybirddizi/article/details/73065667)

## FTP

### FTP的整个流程

FTP（文件传输协议）的整个流程可以分为几个主要步骤。以下是一个典型的FTP会话流程，包括控制连接和数据连接的建立与使用：
1. **建立控制连接**：
   - 客户端发起一个到服务器FTP端口（默认为21号端口）的TCP连接。
   - 服务器接受连接，建立控制连接，用于在客户端和服务器之间交换命令和响应。
2. **用户认证**：
   - 客户端通过控制连接发送`USER`命令，后跟用户名，到服务器。
   - 服务器响应，通常要求客户端发送`PASS`命令和密码进行认证。
   - 客户端发送`PASS`命令和密码（密码以隐式方式发送，不会在命令行显示）。
   - 服务器验证用户名和密码，如果认证成功，允许客户端访问；否则，拒绝访问。
3. **设置传输模式**：
   - 客户端可能需要发送`TYPE`命令来指定数据的类型（如ASCII或二进制）和格式。
4. **建立数据连接**：
   - 根据客户端是使用主动模式还是被动模式，数据连接的建立方式不同。
   - **主动模式（PORT）**：
     - 客户端发送`PORT`命令，指定自己的IP地址和端口号（通常是大于1024的随机端口），等待服务器连接。
     - 服务器接收到`PORT`命令后，会从自己的数据端口（通常是20号端口）主动连接到客户端指定的端口，建立数据连接。
   - **被动模式（PASV）**：
     - 客户端发送`PASV`命令，请求服务器打开一个数据端口并进入被动模式。
     - 服务器选择一个随机端口，并通过控制连接发送给客户端（通常是在一个`227 Entering Passive Mode`响应中）。
     - 客户端接收到服务器的端口号后，主动连接到服务器指定的端口，建立数据连接。
5. **文件传输**：
   - 一旦数据连接建立，客户端可以发送命令来请求文件列表（如`NLST`或`LIST`命令），上传文件（如`STOR`命令），或下载文件（如`RETR`命令）。
   - 如果是下载文件，服务器会通过数据连接发送文件数据到客户端。
   - 如果是上传文件，客户端会通过数据连接发送文件数据到服务器。
6. **结束会话**：
   - 文件传输完成后，数据连接会被关闭。
   - 客户端可以通过发送`QUIT`命令来结束FTP会话。
   - 服务器响应`221 Goodbye`，然后关闭控制连接。
     在整个FTP会话中，控制连接始终开放，用于客户端和服务器之间的命令和响应交换。数据连接则根据需要建立和关闭，用于实际的文件数据传输。FTP的这种设计允许命令和数据传输分离，提高了协议的灵活性和效率。

### FTP指令

在FTP客户端中，有许多指令可用于与FTP服务器进行交互和文件操作。以下是一些常见的FTP指令及其用途：

基本指令

1. **`open`** - 连接到FTP服务器。
   ```sh
   open ftp.example.com
   ```

2. **`user`** - 登录到FTP服务器，提供用户名。
   ```sh
   user username
   ```

3. **`pass`** - 登录到FTP服务器，提供密码。
   ```sh
   pass password
   ```

4. **`bye`** 或 **`quit`** - 断开与FTP服务器的连接。
   ```sh
   bye
   quit
   ```

#### 文件和目录操作

1. **`ls`** 或 **`dir`** - 列出当前目录的文件和子目录。
   ```sh
   ls
   dir
   ```

2. **`cd`** - 更改当前工作目录。
   ```sh
   cd directory_name
   ```

3. **`lcd`** - 更改本地计算机上的当前工作目录。
   ```sh
   lcd local_directory_name
   ```

4. **`get`** - 从服务器下载文件到本地计算机。
   ```sh
   get remote_file local_file
   ```

5. **`mget`** - 下载多个文件。
   ```sh
   mget remote_file1 remote_file2
   ```

6. **`put`** - 上传本地文件到服务器。
   ```sh
   put local_file remote_file
   ```

7. **`mput`** - 上传多个文件。
   ```sh
   mput local_file1 local_file2
   ```

8. **`delete`** - 删除服务器上的文件。
   ```sh
   delete remote_file
   ```

9. **`mdelete`** - 删除多个文件。
   ```sh
   mdelete remote_file1 remote_file2
   ```

10. **`mkdir`** - 在服务器上创建新目录。
    ```sh
    mkdir directory_name
    ```

11. **`rmdir`** - 删除服务器上的目录。
    ```sh
    rmdir directory_name
    ```

#### 会话和连接控制

1. **`status`** - 显示当前连接的状态。
   ```sh
   status
   ```

2. **`pwd`** - 显示服务器上的当前工作目录。
   ```sh
   pwd
   ```

3. **`passive`** - 切换到被动模式。
   ```sh
   passive
   ```

4. **`active`** - 切换到主动模式。
   ```sh
   active
   ```

5. **`binary`** - 切换到二进制模式，用于传输非文本文件。
   ```sh
   binary
   ```

6. **`ascii`** - 切换到ASCII模式，用于传输文本文件。
   ```sh
   ascii
   ```

#### 高级指令

1. **`rename`** - 重命名服务器上的文件。
   ```sh
   rename old_name new_name
   ```

2. **`size`** - 获取服务器上文件的大小。
   ```sh
   size remote_file
   ```

3. **`mdtm`** - 获取服务器上文件的最后修改时间。
   ```sh
   mdtm remote_file
   ```

4. **`help`** 或 **`?`** - 显示可用命令列表或特定命令的帮助信息。
   ```sh
   help
   help command
   ```

这些指令在大多数FTP客户端中都可以使用。使用这些命令时，请确保输入的文件和目录名称准确无误，并且具有必要的权限执行相应的操作。